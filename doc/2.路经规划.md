# 路径规划

**包名**：`hybrid_astar_planner`

**节点名**：`planner_node`、`pose_bridge_node`

**输入**：

|    数据名    | 数据描述 |             数据类型              |       订阅       |
| :----------: | :------: | :-------------------------------: | :--------------: |
|  `mapData`   | 地图文件 |  `nav_msgs::msg::OccupancyGrid`   | `/processed_map` |
| `startPoint` |   起点   | `geometry_msgs::msg::PoseStamped` |  `/start_point`  |
|  `endPoint`  |   终点   | `geometry_msgs::msg::PoseStamped` |   `/goal_pose`   |

**输出**：	

|    数据名     |         数据描述         |       数据类型        |      发布       |
| :-----------: | :----------------------: | :-------------------: | :-------------: |
| `plannedPath` | 路径，包含姿态与方向信息 | `nav_msgs::msg::Path` | `/planned_path` |

**`launch`文件**

`map_loader.launch.py`

* 启动起点桥接节点，因为起点和终点的输入是用Rviz中的`2D pose estimate`和`2D Goal pose`，他们的类型分别是`geometry_msgs/msg/PoseWithCovarianceStamped`和 `geometry_msgs/msg/PoseStamped`，为了保持规划器中起点和终点的一致性，所以选择使用一个桥接节点，将起点的类型转换成和终点一样的类型
* 启动规划器节点
  * 需要订阅地图、起点和终点，每次订阅成功后尝试规划路径
  * 如果地图、起点和终点都成功订阅，则开始路径规划（==待做==）

**参考**：





**疑惑**：

1. 该节点在ROS1中是作为主节点的，其核心执行逻辑和ROS2是不一样的。

   参考GPT，ROS1中在主函数里用`while`循环执行主流程，但在ROS2中不建议这样做，每个节点独立，其功能要么通过回调函数实现，要么通过定时器来实现。

2. 目前来看，地图、起点、终点，都是通过一个缓存队列来存储，每次运行`Run()`函数就从缓存队列里面取一份出来，那么ROS2我应该如何执行这个逻辑呢？

   这个涉及整个系统的调度设计问题，GPT 给出了服务式调度、话题式触发两种方案



```cpp
void run() {
    /*
   	如果没有地图数据，则处理地图数据
    */
    while(是否有起点和终点信息) {
        /*
        执行混合A*算法规划路径，并发布
        */
    }
}
```



