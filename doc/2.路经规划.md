# 路径规划

**包名**：`hybrid_astar_planner`

**节点名**：`planner_node`

**输入**：

|         数据名         | 数据描述 |                   数据类型                   |       订阅       |
| :--------------------: | :------: | :------------------------------------------: | :--------------: |
| `current_costmap_ptr_` | 地图数据 |  `nav_msgs::msg::OccupancyGrid::SharedPtr`   | `/processed_map` |
|   `start_pose_ptr_`    |   起点   | `geometry_msgs::msg::PoseStamped::SharedPtr` |  `/start_point`  |
|    `goal_pose_ptr_`    |   终点   | `geometry_msgs::msg::PoseStamped::SharedPtr` |   `/goal_pose`   |

**输出**：	

|    数据名     |         数据描述         |       数据类型        |      发布       |
| :-----------: | :----------------------: | :-------------------: | :-------------: |
| `plannedPath` | 路径，包含姿态与方向信息 | `nav_msgs::msg::Path` | `/planned_path` |

**`launch`文件**

`map_loader.launch.py`

* 启动规划器节点
  * 需要订阅地图、起点和终点，每次订阅成功后尝试规划路径
  * 如果地图、起点和终点都成功订阅，则开始路径规划（==待做==）

****

**Hybrid A-Star 算法类**

参考源码：

* [qimao7213/Hybrid_A_Star-and-mpc_controller](https://github.com/qimao7213/Hybrid_A_Star-and-mpc_controller/tree/main)
* [zm0612/Hybrid_A_Star: Hybrid A Star algorithm C++ implementation](https://github.com/zm0612/Hybrid_A_Star)

待实现



****



**参考**：





**疑惑**：

1. 该节点在ROS1中是作为主节点的，其核心执行逻辑和ROS2是不一样的。

   参考GPT，ROS1中在主函数里用`while`循环执行主流程，但在ROS2中不建议这样做，每个节点独立，其功能要么通过回调函数实现，要么通过定时器来实现。

   建议使用**话题式触发模式**：地图、起点、终点任一输入到达回调，缓存下来，只有当三者都有且有更新时，触发一次路径规划。需要额外处理以下两个问题：

   * 保证地图、起点和终点的一致性

     *  利用时间戳同步
     * 事件驱动+版本号
     * 使用消息过滤器（message_filters）

   *  ==多次触发规划时的可重入性和中断问题==

     * 可重入性：多线程规划，同时规划新旧多个
     * 终止旧规划，采用最新请求（推荐）：主动中断/抢占机制

     

2. 目前来看，地图、起点、终点，都是通过一个缓存队列来存储，每次运行`Run()`函数就从缓存队列里面取一份出来，那么ROS2我应该如何执行这个逻辑呢？

   这个涉及整个系统的调度设计问题，GPT 给出了服务式调度、话题式触发两种方案



```cpp
void run() {
    /*
   	如果没有地图数据，则处理地图数据
    */
    while(是否有起点和终点信息) {
        /*
        执行混合A*算法规划路径，并发布
        */
    }
}
```



